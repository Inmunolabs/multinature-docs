# 01.1 â€“ Formularios clÃ­nicos: flujo funcional y uso prÃ¡ctico

> Documento complementario a: **[01_formularios_clinicos_rules.md](./01_formularios_clinicos_rules.md)**  
> Este archivo describe el flujo funcional del sistema de formularios clÃ­nicos de Multinature, desde la creaciÃ³n del template hasta la captura y versionado de formularios llenados.

---

## ðŸ§­ FLUJO GENERAL: de template a formulario llenado

### Escenario base

- La especialista **Dra. Ana**, nutriÃ³loga, crea una plantilla personalizada de formulario clÃ­nico.
- Cuando un paciente llega a consulta, ella selecciona esa plantilla y **llena los datos del paciente** basÃ¡ndose en los conceptos definidos previamente.

### 1ï¸âƒ£ CreaciÃ³n del template (una sola vez por especialista o plantilla)

La Dra. Ana crea un nuevo template que llama:

**â€œEvaluaciÃ³n - Adultosâ€**

Y define los siguientes conceptos dentro del template:

| Concepto         | Unidad | Graficable | ObservaciÃ³n |
| ---------------- | ------ | ---------- | ----------- |
| Peso             | kg     | âœ…         |             |
| Estatura         | cm     | âŒ         |             |
| % Grasa corporal | %      | âœ…         |             |
| Cintura          | cm     | âœ…         |             |

Este template se guarda en:

- `form_templates` â†’ nombre: â€œEvaluaciÃ³n - Adultosâ€, `specialist_id` = Dra. Ana
- Flags de control: `is_initial_assessment` (prioridad B) y `is_dietagent_intake` (prioridad A), segÃºn aplique para dietAgent.
- Cada campo se guarda en `form_template_concepts` (uno por cada concepto), relacionÃ¡ndolo con el template, ya sea mediante `concept_id` (si viene del catÃ¡logo) o `custom_name` si es un campo personalizado.

---

### 2ï¸âƒ£ Alta de cita y llenado del formulario

Supongamos que llega el paciente **Carlos PÃ©rez** el 1 de abril. La Dra. Ana:

1. Si no existe, crea una nueva cita (`booking`), de lo contrario selecciona la cita del paciente.
2. Selecciona el template â€œEvaluaciÃ³n - Adultosâ€.
3. Llena los campos uno a uno desde ese template:
   - Peso: `72 kg`
   - Estatura: `1.70 m`
   - % Grasa: `22 %`
   - Cintura: `90 cm`
4. Guarda el formulario.

Esto genera:

- Un nuevo registro en `filled_forms`, relacionado con la cita (`booking_id`).
- Un conjunto de registros en `filled_form_values`, uno por cada campo capturado, copiando:
  - El nombre del concepto (`concept_name`).
  - El valor (`value`), unidad (`unit`), si es graficable (`is_graphable`), y observaciÃ³n (`observation`).

> ðŸ” **Nota:** Al guardar el formulario **no se copian referencias** a `form_template_concepts`.  
> En su lugar, se clona la informaciÃ³n textual del concepto.  
> Esto garantiza que si la plantilla cambia en el futuro, los formularios viejos **no se vean afectados** (independencia histÃ³rica).

---

### 3ï¸âƒ£ ModificaciÃ³n o versionado del formulario

#### EdiciÃ³n reciente (menos de 7 dÃ­as)

- Se permite editar directamente el `filled_form` y sus `filled_form_values`.

#### EdiciÃ³n posterior (>7 dÃ­as)

- El backend crea una **copia del formulario viejo**, lo guarda como un nuevo `filled_form` (para la misma cita) y permite editar esa copia.
- Se conserva el original como versiÃ³n histÃ³rica.

> ðŸ“˜ Regla complementaria:  
> Este comportamiento se refuerza con la propuesta de `template_version` y `template_snapshot` del archivo `01_formularios_clinicos_rules.md`, que permite reconstruir exactamente cÃ³mo era la plantilla usada al llenar cada formulario.

---

### 4ï¸âƒ£ EvoluciÃ³n en el tiempo

El sistema puede graficar la evoluciÃ³n de ciertos conceptos (por ejemplo â€œPesoâ€, â€œCinturaâ€) usando todos los `filled_form_values` con `is_graphable = true` de un mismo paciente, ordenados por fecha de cita (`bookings.booking_date`).

```sql
SELECT
  ffv.concept_name,
  ffv.value_number AS value,
  b.booking_date
FROM filled_form_values ffv
JOIN filled_forms f ON f.id = ffv.filled_form_id
JOIN bookings b ON b.id = f.booking_id
WHERE f.user_id = :patientId
  AND ffv.is_graphable = 1
ORDER BY b.booking_date ASC;
```

---

## ðŸ§± Â¿QuÃ© es un template entonces?

Un **template de formulario clÃ­nico** es un conjunto de **conceptos definidos por un especialista (o por Multinature)** que sirve como **base estructural** para capturar valores en formularios reales.

> Los formularios reales (`filled_forms`) son **instancias** de un template, **llenas con datos de un paciente en una cita especÃ­fica**.

Cada formulario puede considerarse un **snapshot clÃ­nico puntual** dentro de la evoluciÃ³n del paciente.

---

## âš™ï¸ LÃ³gica resumida de tablas

| Tabla                    | PropÃ³sito                                         | Claves principales                                                                                   |
| ------------------------ | ------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `concepts`               | CatÃ¡logo base de conceptos clÃ­nicos reutilizables | `id`, `name`, `field_type`, `description`                                                            |
| `form_templates`         | Plantillas creadas por especialista o globales    | `id`, `specialty_id`, `specialist_id`, `version`, `is_initial_assessment`, `is_dietagent_intake`     |
| `form_template_concepts` | AsociaciÃ³n de conceptos dentro de una plantilla   | `form_template_id`, `concept_id`, `custom_name`, `unit`, `is_graphable`                              |
| `filled_forms`           | Formularios llenados en una cita                  | `booking_id`, `user_id`, `specialist_id`, `template_version`, `filled_by`                            |
| `filled_form_values`     | Respuestas individuales de cada campo             | `filled_form_id`, `concept_id`, `concept_name`, `value`, `unit`, `is_graphable`, `group_description` |

---

## ðŸ§© Reglas operativas y casos especiales

1. **Soft delete de plantillas**

   - `deleted_at` permite desactivar plantillas sin perder relaciÃ³n con formularios antiguos.

2. **ClonaciÃ³n / herencia**

   - `base_template_id` permite crear versiones derivadas o personalizadas de una plantilla global.

3. **Campos personalizados**

   - Si un concepto no existe en `concepts`, puede guardarse con `custom_name` sin `concept_id`.

4. **Responsabilidad compartida (paciente/especialista)**

   - A nivel funcional, el sistema puede usar el campo `filled_by` (ver reglas en `01_formularios_clinicos_rules.md`) para distinguir si el formulario fue llenado por el paciente, el especialista o ambos.

5. **IntegraciÃ³n con dietAgent**
   - Cada `concept_id` sirve como identificador semÃ¡ntico estable para que el agente interprete informaciÃ³n clÃ­nica a lo largo del tiempo.
   - `field_type`, `value_number`, `value_json` y `is_graphable` permitirÃ¡n construir contextos estructurados para inferencia y anÃ¡lisis evolutivo.
   - La selecciÃ³n de plantillas sigue la jerarquÃ­a **A/B/C**:
     1. `is_dietagent_intake = 1` (consulta con `GET /forms/template?isDietagentIntake=true`).
     2. `is_initial_assessment = 1` como fallback.
     3. Plantillas restantes para casos sin cobertura previa.
   - Registrar en `agent_traces` quÃ© nivel se utilizÃ³ durante el intake y persistir los resultados en `agent_evals`.

---

## Resumen visual del flujo

```mermaid
flowchart TD
  A["CreaciÃ³n de template\n(form_templates)"] --> B["DefiniciÃ³n de preguntas\n(form_template_concepts)"]
  B --> C["SelecciÃ³n de paciente y cita\n(bookings)"]
  C --> D["Llenado del formulario\n(filled_forms + filled_form_values)"]
  D --> E["VisualizaciÃ³n / GrÃ¡ficas\n(is_graphable = true)"]
  E --> F["DietAgent / Reportes"]

```

---

## ðŸ“Ž Referencias cruzadas

- **Complementa:** [`01_formularios_clinicos_rules.md`](./01_formularios_clinicos_rules.md)
- **Depende de:** entidades `users`, `bookings`, `specialties`
- **Relevante para:** `forms-api`, `dietAgent`, `reports-api`
